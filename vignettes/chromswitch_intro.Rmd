---
title: "An introduction to *chromswitch* for detecting chromatin state switches"
shorttitle: "An introduction to *chromswitch*"
author: Selin Jessa and Claudia L. Kleinman
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc_float: true
    df_print: paged
abstract: >
    An important question in comparative analysis of epigenomic data is how 
    chromatin state differs between biological conditions. The package 
    chromswitch implements a method for detecting chromatin state switches
    by integrating epigenomic data (ChIP-seq peaks for histone modifications,
    DNase-seq, previously learned chromatin state segmentations, *etc.*) in
    specific genomic regions of interest. Chromswitch transforms data in the
    query region into a sample-by-feature matrix, clusters samples
    hierarchically, and then uses external cluster validity measures to
    predict a switch in chromatin state.
vignette: >
    %\VignetteIndexEntry{An introduction to `chromswitch` for detecting chromatin state switches}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---


Install `r Githubpkg("sjessa/chromswitch")` from GitHub
using `r CRANpkg("devtools")`:
```{r setup, warn = FALSE, message = FALSE}
devtools::install_github("sjessa/chromswitch")
library(chromswitch)
```

# Overview of this vignette

In the Quickstart section, we show a basic analysis with
`chromswitch` using a small dataset included in the package. In the next
section, we very briefly outline the method for detecting chromatin
switches that chromswitch implements. Next, we demonstrate a basic analysis
chromswitch with a detailed discussion of data import, input, parameters
available to the user, and interpretation of chromswitch output. demonstrate how
to construct or import these components. In this section
we use the wrapper functions which
provide one-line commands to call chromatin state switches
based on a single mark
or type of input data. Finally, we demonstrate how the steps of the method
implemented in chromswitch can be run individually, and how this
modularity can be leveraged to perform more complicated analyses, for
example, to incorporate data from multiple histone marks.

# Quickstart

We'll start with a toy dataset containing MACS2 narrow peak calls for H3K4me3
ChIP-seq in 3 brain tissues and 3 other adult tissues from the Roadmap
Epigenomics Project, restricted to a short region on chromosome 19. The data
packaged with chromswitch is described in the manual, and the
documentation can be accessed by running `??chromswitch::H3K4me3` in the
console. In the code below, we prepare a corresponding metadata file,
save a couple regions of interest, and run `chromswitch` on our dataset,
testing both strategies for feature matrix construction. We can then call chromatin state switches by thresholding on the value of
the Consensus score, which sores the similarity between the cluster assignments
and the biological condition labels.

Chromswitch essentially requires 3 inputs:

1. Genomic query region
2. Peaks
3. Metadata dataframe
```{r quickstart}
# Prepare metadata
samples    <- c("E068", "E071", "E074", "E101", "E102", "E110")
outfiles   <- system.file("extdata", paste0(samples, ".H3K4me3.bed"),
                        package = "chromswitch")
conditions <- c(rep("Brain", 3), rep("Other", 3))
metadata   <- data.frame(Sample = samples,
                         H3K4me3 = outfiles,
                         Condition = conditions,
                         stringsAsFactors = FALSE)

# Define query regions
regions <- GenomicRanges::GRanges(seqnames = c("chr19", "chr19"),
                                  ranges = IRanges::IRanges(
                                      start = c(54924104,54874318),
                                      end = c(54929104, 54877536)))

# Run chromswitch using the summary strategy
callSummary(query = regions,     # Input 1: Query region
            peaks = H3K4me3,     # Input 2: Peaks
            metadata = metadata, # Input 3: Metadata dataframe
            normalize_columns = c("qValue", "pValue", "signalValue"),
            mark = "H3K4me3",
            summarize_columns = c("pValue", "qValue", "signalValue"),
            heatmap = FALSE)

# Run chromswitch using the binary strategy
callBinary(query = regions,
           peaks = H3K4me3,
           metadata = metadata)
```

# Overview of the method

Our method for detecting chromatin state switches using epigenomic data
involves three steps, which is reflected in its implementation in the
chromswitch package and the functions available to users. As input,
chromswitch requires epigenetic features represented by their genomic
coordinates and optionally, some associated statistics. Possible examples
include ChIP-seq or DNase-seq peaks, or previously-learned chromatin state
segmentations. Here we'll refer to peaks for simplicity, but the analysis 
is the same for other types of epigenetic features given as intervals.

In the pre-processing phase, the user can set thresholds on any statistics
associated with peaks and filter out peaks below these thresholds
(`filterPeaks()`). These statistics can then be normalized genome-wide for each
sample (`normalizePeaks()`). More detailed discussion of the normalization process
can be found in the documentation of that function.
Both these steps are optional. We then retrieve all the peaks in each sample
which overlap the query region (`retrievePeaks`).

Next, chromswitch transforms the peaks in the query region into a
sample-by-feature matrix using one of two strategies. In the summary strategy
(`summarizePeaks()`), we compute a set of summary statistics from the peaks 
in each sample in the query region. These can include the mean, median, and max
of the statistics associated with the peaks in the input, as well as the 
fraction of the region overlapped by peaks, the number of peaks, and their
average length. Genome-wide normalization of the data is therefore mainly
important if choosing this strategy.

In the binary strategy (`binarizePeaks()`) we
construct a binary matrix where each feature corresponds to a unique peak in the
region, and the matrix holds the binary presence or absence calls of each
unique peak in each sample. We obtain the unique peaks by collapsing the union
of all peaks in the region observed in all samples using a parameter `p`
which specifies how much reciprocal overlap is required between two peaks to
call them the same. Since regions corresponding to the same biological event
can occasionally result in separate peaks during the process of interpretation
of raw signal, peak calling, *etc*, we also introduce an option to combine
peaks which are separated by less than `gap` base pairs (`reducePeaks()`).

Finally, chromswitch clusters samples hierarchically
and then scores the similarity between the inferred cluster assignments and the
known biological condition labels of the samples (`cluster()`).

# Walkthrough of a basic `chromswitch` analysis

## Setup    

First, we'll load other packages we'll use in our analysis:
```{r load_pkg, message = FALSE, warning = FALSE}
library(magrittr)
library(rtracklayer)
library(GenomicRanges)
library(dplyr)
```

## Input

To run `chromswitch`, we essentially need three pieces of information:

1. Metadata which describes the samples and their conditions
2. One or more genomic regions which will serve as query regions (note that
chromswitch acts at the level of individual regions and so will return results for each  region independently)
3. A set of epigenomic features (peaks or chromatin state segmentations,
for example) for each sample

## Obtain data

The package ships with a small dataset that we will analyze to detect brain-
specific chromatin state switches. The dataset contains MACS2 narrow
peak calls for H3K4me3 in a short section of chromosome 19 for six samples,
3 adult brain tissues, 
and 3 other adult tissues. In the code below, we prepare a minimal metadata
dataframe. The metadata dataframe needs at least two
columns, "Sample" which stores the sample IDs, "Condition", which stores the
biological condition labels of the samples; this can be passed to the `metadata`
argument of `chromswitch` functions that require it.

```{r meta}
samples <- c("E068", "E071", "E074", "E101", "E102", "E110")
conditions <- c(rep("Brain", 3), rep("Other", 3))

meta <- data.frame(Sample = samples , Condition = conditions,
                   # Ensure the columns are characters, not factors
                   stringsAsFactors = FALSE)

meta
```

To import BED files containing peak calls,
we can use `r Biocpkg("rtracklayer")` to read the data
into `GRanges` objects, which can be analyzed with `chromswitch`. This chunk
will produce `pk_k4me3`, which is identical to the `H3K4me3` object packaged
with `chromswitch`.

```{r paths}
paths <- system.file("extdata", paste0(samples, ".H3K4me3.bed"),
                     package = "chromswitch")
paths
```

Typically, statistics quantifying enrichment and significance are associated
with peaks returned by standard peak-calling tools - we will need to provide
names and types for all additional columns included in the BED files. These
columns must be the same for all samples, and they must follow the three
required columns (`chromosome`, `start`, and `end`) in the order they're
specified. More information about importing BED files can be obtained by
running `??rtracklayer::BEDFile` in the console to access the `rtracklayer`
documentation.

```{r read}
extra_cols <- c("name" = "character",
                "score" = "integer",
                "strand" = "character",
                "signalValue" = "numeric",
                "pValue" = "numeric",
                "qValue" = "numeric",
                "peak" = "numeric")

# Obtain a list of GRanges objects containing peak calls
pk_k4me3 <- lapply(paths, rtracklayer::import, format = "bed",
                   extraCols = extra_cols)

# Ensure the list is named by sample
names(pk_k4me3) <- meta$Sample
str(pk_k4me3$E068)
```

The same process can be applied to BED files containing epigenomic features
other than peaks (for example, chromatin state segmentations); the `extraCols`
argument to `rtracklayer::import` should be modified to fit the data.

## Applying the summary strategy to detect brain-specific switches

We'll apply `chromswitch` to 5kbp windows surrounding chromatin state
switches in a few genes on chromosome 19:

```{r regions}
query <- data.frame(
    gene = c("CACNG8", "TTYH1", "LENG8"),
    TSS = c(54466290, 54926605, 54960065), stringsAsFactors = FALSE) %>% 
    dplyr::mutate(chromosome = "chr19",
           start = TSS - 2500,
           end = TSS + 2500) %>%
    dplyr::select(-TSS) %>% 
    makeGRangesFromDataFrame(keep.extra.columns = TRUE)

query
```

The `makeGRangesFromDataFrame` function from `r Biocpkg("GenomicRanges")` is
handy for converting a list of query regions in a dataframe into a `GRanges`
object (remember the `keep.extra.columns = TRUE` argument to preserve any
additional data associated with the regions).

We'll first run a basic analysis using the summary strategy
for constructing 
feature matrices, summarizing on the `qValue` and `signalValue` statistics only.
This means that for each sample, the features used to the cluster samples in the
region will be the mean, median, and maximum of these two statistics across
peaks. We will apply genome-wide normalization to the same columns we will use
in the feature matrices. All the computations described in the method are 
wrapped in one command; in later sections we'll explore running each 
step of the method (preprocessing, feature matrix construction, clustering)
individually.

Note that the column names passed to arguments in the wrappers (*e.g.*
`normalize_columns`, `summarize_columns`, *etc*) must match exactly the column
names in the BED files.

```{r summary_basic}

out <- callSummary(query = query,
                peaks = pk_k4me3,
                metadata = meta,
                mark = "H3K4me3",
                normalize = TRUE,
                normalize_columns = c("qValue", "signalValue"),
                summarize_columns = c("qValue", "signalValue"),
                optimal_clusters = TRUE,
                heatmap = FALSE)

out

```

## Output

The basic output of `chromswitch` is a tidy dataframe which includes:

* The query regions and any additional data associated with the query (here, 
the name of the gene)
* The number of clusters inferred in the region ($k = 2$ if
`optimal_clusters = FALSE`,
otherwise, the optimal set of clusters is obtained by selecting the clusters
with the highest average Silhouette width, displayed in the next column)
* The Average Silhouette score, which measures cluster compactness and
separation, and can be interpreted as assessing the internal consistency
of the clustering
* A score of the similarity between the inferred clusters and the
biological condition labels of the samples (here, Brain and Other), labeled
as "Consensus", which is an average of the Adjusted Rand Index (ARI),
the Normalized Mutual Information (NMI), and the V measure. This is the score
we recommend to use for later filtering, and thresholding. This score takes
on values between -1 and 1, where 1 represents a perfect agreement between
cluster assignments and the biological conditions of the sample
* The cluster assignments for each sample, one sample per column

We can threshold on the consensus score to subset the query regions to those
containing putative chromatin state switches:

```{r threshold}

out %>% 
    dplyr::filter(Consensus >= 0.75)
```

Let's explore some more options for detecting chromatin state switches
with chromswitch. The options are briefly described in the comments,
but you can obtain additional explanation of arguments and explore others
not covered here by running `??chromswitch::callSummary`.
```{r summary2}

out2 <- callSummary(# Standard arguments of the function
                query = query,
                peaks = pk_k4me3,
                metadata = meta,
                mark = "H3K4me3",

                # For quality control, filter peaks based on associated stats
                # prior to constructing feature matrices
                filter = TRUE,
                # Provide column names and thresholds to use in the same order
                filter_columns = c("qValue", "signalValue"),
                filter_thresholds = c(10, 4),

                # Normalization options
                normalize = TRUE,
                normalize_columns = c("qValue", "signalValue"),

                # Options for feature matrix construction
                summarize_columns = c("qValue", "signalValue"),

                # In addition to summarizing peak statistics,
                # we can also optionally summarize peak length, and compute the
                # fraction of the region overlapped by peaks
                # and the number of peaks
                length = FALSE,
                fraction = TRUE,
                n = FALSE,
                
                # Set this option to TRUE to return the optimal number
                # of clusters, otherwise require k = 2
                optimal_clusters = TRUE,
                
                # Set this to TRUE to save a PDF of the heatmap
                # for each region to the current working directory
                heatmap = FALSE)


out2
```

The summary approach can be applied to epigenomic data where there
are no statistics associated with the features (peaks, states, *etc*). In this
case, set `summarize_columns = NULL`, `filter = FALSE`, `normalize = FALSE`,
and ensure that one or more of `length`, `n`, and `fraction` are set to `TRUE`.

## Applying the binary strategy to detect brain-specific switches

The binary strategy requires approximately the same basic
input as the summary strategy. It also uses two tuning parameters:

1. `gap` which is the distance between peaks in the same sample below which
two peaks should be merged. This preprocessing step is optional, and is 
controlled by the option `reduce`
2. `p` which is the fraction of reciprocal overlap required to call two
peaks the same. This rule is used to obtain a set of unique peaks observed
across samples in the query region, and to assign binary presence or absence
of each peak in each sample to construct the feature matrix.

We use default values of `gap = 300` and `p = 0.4`, but the method is robust
to changes in these parameters within reasonable ranges.

The other option unique to this strategy is `n_features`. The number of features
in the matrix used for clustering corresponds to the number of unique peaks
that `chromswitch` identifies for these samples in the query region, and
this option controls whether to include an additional column recording 
the number of features in the output.

```{r pa_basic}
out3 <- callBinary(query = query,
                peaks = pk_k4me3,
                metadata = meta,
                reduce = TRUE,
                gap = 300,
                p = 0.4,
                n_features = TRUE,
                optimal_clusters = TRUE,
                heatmap = FALSE)

out3
```

Again, threshold the output to obtain putative switches: 
```{r threshold2}

out3 %>% 
    dplyr::filter(Consensus >= 0.75)

```


# Step-by-step analysis

## Summary approach

## Binary approach

# Leveraging the modularity of *chromswitch* to incorporate multiple marks


# Session Info
```{r session}
sessionInfo()
```
