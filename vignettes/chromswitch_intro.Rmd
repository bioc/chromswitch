---
title: "An introduction to *chromswitch* for detecting chromatin state switches"
shorttitle: "An introduction to *chromswitch*"
author:
- Selin Jessa
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document2:
    toc_float: true
    df_print: paged
abstract: >
    This vignette describes the method for detecting chromatin state switches
    implemented in *chromswitch*, and demonstrates some example analyses.
vignette: >
    %\VignetteIndexEntry{An introduction to `chromswitch` for detecting chromatin state switches}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---


# Overview of the method

# Overview of this document

To run `chromswitch`, we essentially need three pieces of information:

1. Metadata which describes the samples and their conditions
2. One or more genomic regions which will serve as query regions ^[`chromswitch`
acts at the level of individual regions and so will return results for each 
region independently]
3. A set of epigenomic features (peaks or chromatin state segmentations,
for example) for each sample

In the Quickstart section, we demonstrate how to use data packaged with
`chromswitch` to quickly test the method on two example query regions.

In the next section, we demonstrate how to construct or import these components
into formats that `chromswitch` can analyze. We then call chromatin state
switches for a few example regions using the wrapper functions which provide
one-line commands to call chromatin state switches based on a single mark
or type of input data, describe `chromswitch` output, and discuss some of the
options available to the user.

Finally, we demonstrate how the steps of the method
implemented in chromswitch can be run individually, and how this modularity
can be leveraged to perform more complicated analyses, for example, incorporating
data from multiple marks.

# Install

We can install `r Githubpkg("selinj/chromswitch")` from GitHub using `r CRANpkg("devtools")`:
```{r setup}
devtools::install_github("selinj/chromswitch")
library(chromswitch)
```

# Quickstart

We'll start with a toy dataset containing MACS2 narrow peak calls for 3 brain
tissues and 3 other adult tissues from the Roadmap Epigenomics Program,
restricted to a short region on chromosome 19. The data packaged with
chromswitch is described in the manual, and the
documentation can be accessed by running `??chromswitch::H3K4me3` in the console.
In the code below, we prepare a corresponding metadata file, save a couple regions
of interest, and run `chromswitch` on our dataset, testing both strategies
for feature matrix construction.

We can then call chromatin state switches by thresholding on the value of
the Consensus score, one of the columns in the output.
```{r qs_pa}

# Prepare metadata
samples <- c("E068", "E071", "E074", "E101", "E102", "E110")

outfiles <- system.file("extdata", paste0(samples, ".H3K4me3.bed"),
                        package = "chromswitch")

conditions <- c(rep("Brain", 3), rep("Other", 3))

metadata <- data.frame(Sample = samples,
    H3K4me3 = outfiles,
    Condition = conditions,
    stringsAsFactors = FALSE)

# Define query regions
regions <- GenomicRanges::GRanges(seqnames = c("chr19", "chr19"),
    ranges = IRanges::IRanges(start = c(54924104, 54874318),
                                end = c(54929104, 54877536)))

# Run chromswitch using the whole-region strategy
callSummary(query = regions,
                peaks = H3K4me3,
                metadata = metadata,
                normalize_columns = c("qValue", "pValue", "signalValue"),
                mark = "H3K4me3",
                summarize_columns = c("pValue", "qValue", "signalValue"),
                heatmap = FALSE)

# Run chromswitch using the position-aware strategy
callBinary(query = regions,
                  peaks = H3K4me3,
                  metadata = metadata)

```


# A basic `chromswitch` analysis

## Setup    

First, we'll load other packages we'll use in our analysis:
```{r load_pkg}
library(magrittr)
library(rtracklayer)
library(GenomicRanges)
library(dplyr)
```

## Obtain data

The package ships with a small dataset that we will analyze to detect brain-
specific chromatin state switches. The dataset contains MACS2 narrow
peak calls for H3K4me3 in a short section of chromosome 19 for six samples,
3 adult brain tissues, 
and 3 other adult tissues. In the code below, we prepare a minimal metadata
dataframe. The metadata dataframe needs at least two
columns, "Sample" which stores the sample IDs, "Condition", which stores the
biological condition labels of the samples; this can be passed to the `metadata`
argument of `chromswitch` functions that require it.

```{r meta}
samples <- c("E068", "E071", "E074", "E101", "E102", "E110")
conditions <- c(rep("Brain", 3), rep("Other", 3))

meta <- data.frame(Sample = samples , Condition = conditions,
                   # Ensure the columns are characters, not factors
                   stringsAsFactors = FALSE)

meta
```

To import BED files containing peak calls,
we can use `r Biocpkg("rtracklayer")` to read the data
into `GRanges` objects, which can be analyzed with `chromswitch`. This chunk
will produce `pk_k4me3`, which is identical to the `H3K4me3` object packaged
with `chromswitch`.

```{r paths}
paths <- system.file("extdata", paste0(samples, ".H3K4me3.bed"),
                     package = "chromswitch")
paths
```

Typically, statistics quantifying enrichment and significance are associated
with peaks returned by standard peak-calling tools - we will need to provide
names and types for all additional columns included in the BED files. These
columns must be the same for all samples, and they must follow the three
required columns (`chromosome`, `start`, and `end`) in the order they're
specified. More information about importing BED files can be obtained by
running `??rtracklayer::BEDFile` in the console to access the `rtracklayer`
documentation.

```{r read}
extra_cols <- c("name" = "character",
                "score" = "integer",
                "strand" = "character",
                "signalValue" = "numeric",
                "pValue" = "numeric",
                "qValue" = "numeric",
                "peak" = "numeric")

# Obtain a list of GRanges objects containing peak calls
pk_k4me3 <- lapply(paths, rtracklayer::import, format = "bed",
                   extraCols = extra_cols)

# Ensure the list is named by sample
names(pk_k4me3) <- meta$Sample
str(pk_k4me3$E068)
```

The same process can be applied to BED files containing epigenomic features
other than peaks (for example, chromatin state segementations); the `extraCols`
aregument to `rtracklayer::import` should be modified to fit the data.


## Applying the whole-region strategy to detect brain-specific switches

We'll apply `chromswitch` to 5kbp windows surrounding chromatin state
switches in a few genes on chromosome 19:

```{r regions}
query <- data.frame(
    gene = c("CACNG8", "TTYH1", "LENG8"),
    TSS = c(54466290, 54926605, 54960065), stringsAsFactors = FALSE) %>% 
    dplyr::mutate(chromosome = "chr19",
           start = TSS - 2500,
           end = TSS + 2500) %>%
    dplyr::select(-TSS) %>% 
    makeGRangesFromDataFrame(keep.extra.columns = TRUE)

query
```

The `makeGRangesFromDataFrame` function from `r Biocpkg("GenomicRanges")` is
handy for converting a list of query regions in a dataframe into a `GRanges`
object (remember the `keep.extra.columns = TRUE` argument to preserve any
additional data associated with the regions).

We'll first run a basic analysis using the whole-region strategy for constructing 
feature matrices, summarizing on the `qValue` and `signalValue` statistics only.
This means that for each sample, the features used to the cluster samples in the
region will be the mean, median, and maximum of these two statistics across
peaks. We will apply genome-wide normalization to the same columns we will use
in the feature matrices. All the computations described in the method are 
wrapped in one command; in later sections we'll explore running each 
step of the method (preprocessing, feature matrix construction, clustering)
individually.

Note that the column names passed to arguments in the wrappers (*e.g.*
`normalize_columns`, `summarize_columns`, *etc*) must match exactly the column
names in the BED files.

```{r wr_basic}

out <- callSummary(query = query,
                peaks = pk_k4me3,
                metadata = meta,
                mark = "H3K4me3",
                normalize = TRUE,
                normalize_columns = c("qValue", "signalValue"),
                summarize_columns = c("qValue", "signalValue"),
                optimal_clusters = TRUE,
                heatmap = FALSE)

out

```

The basic output of `chromswitch` is a tidy dataframe which includes:

* The query regions and any additional data associated with the query (here, 
the name of the gene)
* The number of clusters inferred in the region ($k = 2$ if
`optimal_clusters = FALSE`,
otherwise, the optimal set of clusters is obtained by selecting the clusters
with the highest average Silhouette width, displayed in the next column)
* Several measures of the similarity between the inferred clusters and the
biological condition labels of the samples (here, Brain and Other) - the last
column is the Consensus score, an average of the Adjusted Rand Index (ARI),
the Normalized Mutual Information (NMI), and the V measure. This is the score
we recommend to use for later filtering, and thresholding.
* The cluster assignments for each sample

We can threshold on the consensus score to subset the query regions to those
containing putative chromatin state switches:

```{r threshold}

out %>% 
    dplyr::filter(Consensus >= 0.75) %>% 
    dplyr::select(region, gene, k, Consensus,
                      E068, E071, E074, E101, E102, E110)

```

Let's explore some more options for detecting chromatin state switches
with chromswitch. The options are briefly described in the comments,
but you can obtain additional explanation of arguments and explore others
not covered here by running `??chromswitch::callSummary`.
```{r wr}

out2 <- callSummary(# Standard arguments of the function
                query = query,
                peaks = pk_k4me3,
                metadata = meta,
                mark = "H3K4me3",

                # For quality control, filter peaks based on associated stats
                # prior to constructing feature matrices
                filter = TRUE,
                # Provide column names and thresholds to use in the same order
                filter_columns = c("qValue", "signalValue"),
                filter_thresholds = c(10, 4),

                # Normalization options
                normalize = TRUE,
                normalize_columns = c("qValue", "signalValue"),

                # Options for feature matrix construction
                summarize_columns = c("qValue", "signalValue"),

                # In addition to summarizing peak statistics,
                # we can also optionally summarize peak length, and compute the
                # fraction of the region overlapped by peaks
                # and the number of peaks
                length = FALSE,
                fraction = TRUE,
                n = FALSE,
                
                # Set this option to TRUE to return the optimal number
                # of clusters, otherwise require k = 2
                optimal_clusters = TRUE,
                
                # Set this to TRUE to save a PDF of the heatmap
                # for each region to the current working directory
                heatmap = FALSE)


out2
```

The whole-region approach can be applied to epigenomic data where there
are no statistics assoicated with the features (peaks, states, *etc*). In this
case, set `summarize_columns = NULL`, `filter = FALSE`, `normalize = FALSE`,
and ensure that one or more of `length`, `n`, and `fraction` are set to `TRUE`.

## Applying the position-aware strategy to detect brain-specific switches

The position-aware strategy requires approximately the same basic
input as the whole-region strategy. It also uses two tuning parameters:

1. `gap` which is the distance between peaks in the same sample below which
two peaks should be merged. This preprocessing step is optional, and is 
controlled by the option `reduce`
2. `p` which is the fraction of reciprocal overlap required to call two
peaks the same. This rule is used to obtain a set of unique peaks observed
across samples in the query region, and to assign binary presence or absence
of each peak in each sample to construct the feature matrix.

We use default values of `gap = 300` and `p = 0.4`, but the method is robust
to changes in these parameters within reasonable ranges.

The other option unique to this strategy is `n_features`. The number of features
in the matrix used for clustering corresponds to the number of unique peaks
that `chromswitch` identifies for these samples in the query region, and
this option controls whether to include an additional column recording 
the number of features in the output.

```{r pa_basic}
out3 <- callBinary(query = query,
                peaks = pk_k4me3,
                metadata = meta,
                reduce = TRUE,
                gap = 300,
                p = 0.4,
                n_features = TRUE,
                optimal_clusters = TRUE,
                heatmap = FALSE)

out3
```

Again, threshold the output to obtain putative switches: 
```{r threshold2}

out3 %>% 
    dplyr::filter(Consensus >= 0.75) %>% 
    dplyr::select(region, gene, k, Consensus,
                      E068, E071, E074, E101, E102, E110)

```


# Step-by-step analysis

## Whole-region approach

## Position-aware approach

# Leveraging the modularity of *chromswitch* to incorporate multiple marks


# Session Info
```{r session}
sessionInfo()
```
