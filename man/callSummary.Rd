% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrappers.R
\name{callSummary}
\alias{callSummary}
\title{callSummary}
\usage{
callSummary(query, peaks, metadata, mark, filter = FALSE,
  filter_columns = NULL, filter_thresholds = NULL, normalize = TRUE,
  normalize_columns = NULL, tail = 0.005, summarize_columns,
  length = FALSE, fraction = TRUE, n = FALSE, heatmap = TRUE,
  titles = NULL, outdir = NULL, optimal_clusters = FALSE,
  estimate_state = FALSE, signal_col = NULL, test_condition = NULL,
  BPPARAM = bpparam())
}
\arguments{
\item{query}{GRanges list containing one or more genomic regions of interest
in which to call a switch. The output dataframe will contain one row per
region in \code{query}.}

\item{peaks}{List of GRanges objects storing peak calls for each sample,
where element names correspond to sample IDs}

\item{metadata}{A dataframe with at least two columns: "Sample" which stores
the sample IDs, "Condition", which stores the biological condition labels
of the samples}

\item{mark}{Character specifying the histone mark or ChIP-target,
for example, "H3K4me3"}

\item{filter}{(Optional) logical value, filter peaks based on thresholds on
peak statistics? Default: FALSE. The filter step is described in
\code{\link{filterPeaks}}.}

\item{filter_columns}{If \code{filter} is TRUE, a chracter vector
corresponding to names of columns in the peak metadata by which to filter
peaks. If \code{filter} is FALSE, not used.}

\item{filter_thresholds}{If \code{filter} is TRUE, a numeric vector
corresponding to lower cutoffs applied to metadata columns in order to filter
peaks. Provide one per column specified in \code{filter_columns}, in the same
order. If \code{filter} is FALSE, not used.}

\item{normalize}{(Optional) logical value, normalize peak statistics
genome-wide for each sample? Default: TRUE. The normalization step is
described in \code{\link{normalizePeaks}}.}

\item{normalize_columns}{If \code{normalize} is TRUE, a character vector
corresponding to names of columns in the peak metadata to normalize
genome-wide for each sample. If \code{normalize} is FALSE, not used.}

\item{tail}{(Optional) if \code{normalize} is TRUE, specifies the fraction
of extreme values in each tail to bound during normalization. More details at
\code{\link{normalizePeaks}}.}

\item{summarize_columns}{Character vector of column names on which to compute
summary statistics during feature matrix construction. These statistics
become the features of the matrix.}

\item{length}{(Optional) Logical value, during feature matrix construction,
compute the mean, median, and max of peak length? Default: FALSE}

\item{fraction}{(Optional) Logical value, during feature matrix construction,
compute the fraction of the region overlapped by peaks? Default: TRUE}

\item{n}{(Optional) Logical value, during feature matrix construction,
compute the number of peaks in the region? Default: FALSE}

\item{heatmap}{(Optional) Logical value, plot the heatmap corresponding to
the hierarchical clustering result? Default: TRUE}

\item{titles}{(Optional)  if \code{heatmap} is TRUE, a character vector
of the same length as \code{query}, specifying the title to use when plotting
each heatmap (e.g. a gene name), also reused as the
prefix of the name of the file where the heatmap is saved. By default, the
title is the genomic coordinates of the region in the form "chrN:start-end"}

\item{outdir}{(Optional) if \code{heatmap} is TRUE, the name of the directory
where heatmaps should be saved}

\item{optimal_clusters}{(Optional) Logical value indicate whether to cluster
samples into two groups, or to find the optimal clustering solution by
choosing the set of clusters which maximizes the Average Silhouette width}

\item{estimate_state}{(Optional) Logical value indicating whether to include
a column "state" in the output specifying the estimated chromatin state of
a test condition. The state will be on of "ON", "OFF", or NA, where the
latter results if a binary switch between the conditions is unclear.
Default: FALSE.}

\item{signal_col}{(Optional) If \code{estimate_state} is TRUE, string
specifying the name of the column in the original peak files which
corresponds to the level of enrichment in the region, e.g. fold change}

\item{test_condition}{(Optional) If \code{estimate_state} is TRUE, string
specifying one of the two biological condtions in \code{metadata$Condition}
for which to estimate chromatin state.}

\item{BPPARAM}{(Optional) instance of \code{BiocParallel:BiocParallelParam}
used to determine the back-end used for parallel computations when performing
the analysis on more than one region.}
}
\value{
Data frame with one row per region in \code{query}. Contains the
coordinates of the region, the number of inferred clusters, the computed
cluster validity statistics, and the cluster assignment for each sample.
}
\description{
One of two main functions in the \code{chromswitch} package, this function
detects a switch in chromatin state in one or
more regions given ChIP-seq peak calls for one mark, executing the entire
algorithm from preprocessing to evaluating the clustering results,
using the summary strategy.
}
\details{
This strategy constructs a sample-by-feature matrix to use as input for
hierarchical clustering by computing, for each sample, a vector of summary
statistics based on that sample's peaks in the query region. The summary
statistics are generally based on the enrichment statistics associated with
each peak as returned by the peak calling too, which might include, for
example, a p value and fold change.
}
\examples{

samples <- c("E068", "E071", "E074", "E101", "E102", "E110")
outfiles <- system.file("extdata", paste0(samples, ".H3K4me3.bed"),
package = "chromswitch")
Conditions <- c(rep("Brain", 3), rep("Other", 3))

metadata <- data.frame(Sample = samples,
    H3K4me3 = outfiles,
    Condition = Conditions,
    stringsAsFactors = FALSE)

regions <- GRanges(seqnames = c("chr19", "chr19"),
    ranges = IRanges(start = c(54924104, 54874318),
                                end = c(54929104, 54877536)))

callSummary(query = regions,
                peaks = H3K4me3,
                metadata = metadata,
                normalize_columns = c("qValue", "pValue", "signalValue"),
                mark = "H3K4me3",
                summarize_columns = c("pValue", "qValue", "signalValue"),
                heatmap = FALSE,
                BPPARAM = BiocParallel::SerialParam())

}
