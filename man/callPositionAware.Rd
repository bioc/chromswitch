% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrappers.R
\name{callPositionAware}
\alias{callPositionAware}
\title{callPositionAware}
\usage{
callPositionAware(query, peaks, metadata, filter = FALSE,
  filter_columns = NULL, filter_thresholds = NULL, reduce = TRUE,
  gap = 300, p = 0.4, heatmap = TRUE, titles = NULL, outdir = NULL)
}
\arguments{
\item{query}{GRanges list containing one or more genomic regions of interest
in which to call a switch. The output dataframe will contain one row per
region in \code{query}.}

\item{peaks}{List of GRanges objects storing peak calls for each sample,
where element names correspond to sample IDs}

\item{metadata}{A dataframe with at least two columns: "Sample" which stores
the sample IDs, "Group", which stores the biological condition labels
of the samples}

\item{filter}{Optional: logical value, filter peaks based on thresholds on
peak statistics? Default: FALSE. The filter step is described in
\code{\link{filterPeaks}}.}

\item{filter_columns}{If \code{filter} is TRUE, a chracter vector
corresponding to names of columns in the peak metadata by which to filter
peaks. If \code{filter} is FALSE, not used.}

\item{filter_thresholds}{If \code{filter} is TRUE, a numeric vector
corresponding to lower cutoffs applied to metadata columns in order to filter
peaks. Provide one per column specified in \code{filter_columns}, in the same
order. If \code{filter} is FALSE, not used.}

\item{reduce}{Optional: logical value, if TRUE, reduce gaps between nearby
peaks in the same sample. See more at \code{\link{reducePeaks}}.
Default: TRUE}

\item{gap}{Numeric value, specifying the threshold distance for merging.
Peaks in the same sample which are within this many bp of each other will
be merged. Default: 300}

\item{p}{Numeric value in [0, 1] giving the fraction of reciprocal overlap
to require. Default: 0.4}

\item{heatmap}{Optional: Logical value, plot the heatmap corresponding to
the hierarchical clustering result? Default: TRUE}

\item{titles}{Optional:  if \code{heatmap} is TRUE, a character vector
of the same length as \code{query}, specifying the title to use when plotting
each heatmap (e.g. a gene name), also reused as the
prefix of the name of the file where the heatmap is saved. By default, the
title is the genomic coordinates of the region in the form "chrN:start-end"}

\item{outdir}{Optional: if \code{heatmap} is TRUE, the name of the directory
where heatmaps should be saved}
}
\value{
Data frame with one row per region in \code{query}. Contains the
coordinates of the region, the number of inferred clusters, the computed
cluster validity statistics, and the cluster assignment for each sample.
}
\description{
One of two main functions in the \code{chromswitch} package, this function
detects a switch in chromatin state in one or
more regions given ChIP-seq peak calls for one mark, executing the entire
algorithm from preprocessing to evaluating the clustering results,
using the whole-region strategy.
}
\details{
This strategy constructs a sample-by-feature matrix to use as input for
hierarchical clustering by first assembling the set of unique peaks observed
in the region across samples. Then for each unique peak, we model the
presence or absence of that peak in each sample, resulting in a binary
feature matrix.
}
\examples{

samples <- c("brain1", "brain2", "brain3", "other1", "other2", "other3")
outfiles <- system.file("extdata", paste0(samples, ".H3K4me3.bed"),
package = "chromswitch")
groups <- c(rep("Brain", 3), rep("Other", 3))

metadata <- data.frame(Sample = samples,
    H3K4me3 = outfiles,
    Group = groups,
    stringsAsFactors = FALSE)

regions <- GenomicRanges::GRanges(seqnames = c("chr19", "chr19"),
    ranges = IRanges::IRanges(start = c(54924104, 54874318),
                                end = c(54929104, 54877536)))

callPositionAware(query = regions, peaks = H3K4me3, metadata = metadata)

}
